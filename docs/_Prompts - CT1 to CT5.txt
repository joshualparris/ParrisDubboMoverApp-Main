_Prompt 1


Here’s a beefed-up CT1 you can paste straight into Cursor / VS Code 👇
CT1 – Project Scaffolding & Base Architecture


You are an expert full-stack TypeScript engineer.


Create a new monorepo-style project called `pdm-parris-dubbo-mover` that will eventually implement the “ParrisDubboMover (PDM)” app described in a separate design document. This is **CT1**, the first step; later prompts (CT2, CT3, etc.) will add the full data model, modules, and features. For now, focus on clean scaffolding and a solid developer experience.


## High-level goals


- Monorepo with:
  - A **TypeScript React** frontend (Vite) as a single-page app.
  - A **Node.js + Express + TypeScript + SQLite** backend API.
- Simple dev experience: **one command** from the repo root to start both client and server.
- Working health-check:
  - Backend: `GET /api/health` returns JSON `{ "status": "ok" }`.
  - Frontend: Home page shows “PDM App running” and can successfully call `/api/health` via the dev server.


Use **Node 20+** and **React 18+**.


---


## 1. Repo structure


Create this structure:


- `pdm-parris-dubbo-mover/`
  - `package.json`
  - `README.md`
  - `client/`  (React + Vite + TS)
  - `server/`  (Node + Express + TS)
  - `.gitignore`
  - (any config files like `.eslintrc`, `prettier.config`, etc. if you add them)


### Root `package.json`


- Use workspaces or simple scripts that delegate to `client` and `server`.
- Include at least these scripts:


  - `"install:all"` – runs install in both `client` and `server` (e.g. using `npm run` or `npm --workspace` depending on how you structure it).
  - `"dev"` – runs **both** client and server concurrently.
  - `"dev:client"` – runs the Vite dev server.
  - `"dev:server"` – runs the Express server in watch mode.
  - `"build"` – builds client and server (can be placeholders for now, but wire them up).
  - `"lint"` – placeholder or basic lint (optional, but preferred).


- Use `concurrently` (or similar) so that `npm run dev` from the root starts both processes.


---


## 2. Backend (server)


Create a TypeScript Express server in `server/`:


### Dependencies (server)


- Runtime:
  - `express`
  - `better-sqlite3` (preferred) **or** `sqlite3` (pick one and use it consistently)
  - `cors`
- Dev:
  - `typescript`
  - `ts-node-dev` **or** `nodemon` + `ts-node`
  - `@types/node`
  - `@types/express`


### Server layout


Inside `server/`, create something like:


- `package.json`
- `tsconfig.json`
- `src/`
  - `index.ts`          (entry point)
  - `app.ts`            (Express app setup)
  - `routes/health.ts`  (health route)
  - `db/`
    - `index.ts`        (SQLite connection helper)


### Behaviour


1. **Express app basics**
   - Create an Express app in `app.ts`.
   - Use JSON body parsing middleware.
   - Enable CORS (allow requests from `http://localhost:3000` during dev).
   - Mount routes under `/api`.


2. **Health route**
   - In `routes/health.ts`, define a router that exposes:
     - `GET /api/health` → returns status code `200` and JSON:
       ```json
       { "status": "ok" }
       ```


3. **Server entry**
   - In `index.ts`, import the app and start an HTTP server on port **4000** by default.
   - Read the port from `process.env.PORT || 4000`.
   - Log a clear message when the server is running (e.g. `Server listening on http://localhost:4000`).


4. **SQLite setup**
   - In `db/index.ts`, set up a simple connection to a SQLite database file, for example:
     - DB file: `./data/pdm.db` (create a `data/` folder if needed).
   - Export a reusable database instance (e.g. with `better-sqlite3`).
   - For CT1, it’s enough to:
     - Open the DB.
     - Optionally create a simple table (e.g. `app_meta` with a single row) just to verify the DB schema can be created.
   - Don’t implement the full data model yet; that will be done in later CT prompts.


5. **Server scripts**


- `server/package.json` should include:


  - `"dev"` – runs the server in watch mode using `ts-node-dev` or `nodemon` (e.g. `ts-node-dev --respawn src/index.ts`).
  - `"build"` – compiles TypeScript to JavaScript (e.g. `tsc`).
  - `"start"` – runs the compiled JavaScript (e.g. `node dist/index.js`).


- `tsconfig.json` should:
  - Target a modern ECMAScript (e.g. ES2020).
  - Output compiled JS to `dist/`.
  - Use `"module": "commonjs"` or `"module": "esnext"` depending on how you configure Node; just make it consistent and working.


---


## 3. Frontend (client)


Create a React + TypeScript app in `client/` using **Vite**.


### Dependencies (client)


- Runtime:
  - `react`
  - `react-dom`
  - `react-router-dom`
- Dev:
  - `vite`
  - `@vitejs/plugin-react-swc` (or standard React plugin)
  - `typescript`
  - `@types/react`
  - `@types/react-dom`


### Vite setup


- Configure the dev server to run on port **3000**.
- Configure a **proxy** so that requests to `/api` are forwarded to the backend on `http://localhost:4000`.  
  Example: in `vite.config.ts`, set `server.proxy['/api']` appropriately.


This ensures `http://localhost:3000/api/health` during dev reaches the Express server.


### Basic app layout


Implement a minimal but realistic starting point:


- `client/src/main.tsx` (entry)
- `client/src/App.tsx`
- `client/index.html`


In `App.tsx`:


- Use `react-router-dom` with a basic `<BrowserRouter>`.
- For now, create a very simple route structure, anticipating future modules:
  - `/` – Home / Dashboard
  - Optionally stub routes like `/housing`, `/work`, `/childcare`, `/health`, etc. with placeholder `<div>`s.


On the **Home page**:


- Render a heading or main text: **“PDM App running”**.
- Add a small component that:
  - On mount (e.g. `useEffect`), calls `GET /api/health` using `fetch`.
  - Displays the returned status text somewhere on the page (e.g. “API Health: ok” or an error message if the call fails).


Make sure TypeScript types are correct and there are no compile errors.


---


## 4. Tooling & DX (optional but preferred)


If time and complexity allow, set up:


- Basic ESLint + Prettier config for both client and server:
  - Shared base rules (e.g. `@typescript-eslint`).
- A `.gitignore` in the repo root that ignores:
  - `node_modules`
  - `dist`
  - `build`
  - `*.log`
  - SQLite DB files in `server/data/` (except maybe a sample seed if you choose to include one).


These are optional for CT1 but improve the experience.


---


## 5. README


Create a `README.md` at the repo root with:


- Project name: **ParrisDubboMover (PDM)**.
- Short description:
  - E.g. “A browser-based mission control app for the Parris family’s Bendigo → Dubbo move.”
- Tech stack summary:
  - React + TypeScript + Vite frontend
  - Node + Express + TypeScript backend
  - SQLite via better-sqlite3 (or sqlite3)
- Setup instructions (explicit):


  1. `cd pdm-parris-dubbo-mover`
  2. `npm run install:all` (or describe the exact install commands)
  3. `npm run dev`
  4. Visit `http://localhost:3000` in the browser.


- Quick verification steps:
  - Home page shows “PDM App running”.
  - `http://localhost:3000/api/health` returns `{ "status": "ok" }` in the browser or via curl/Postman.


---


## 6. Acceptance criteria


For CT1 to be considered complete:


1. From the repo root, I can run a **single command** (`npm run dev` or similar) that:
   - Starts the backend on port **4000**.
   - Starts the Vite dev server on port **3000**, with proxying of `/api` to `http://localhost:4000`.
2. Visiting `http://localhost:3000/` in a browser shows:
   - A React app with text “PDM App running”.
   - A visible indicator of the API health check (e.g. “API Health: ok”).
3. Visiting `http://localhost:3000/api/health` in a browser returns:
   - HTTP 200
   - JSON `{ "status": "ok" }`.
4. The SQLite database file is created and opened successfully by the backend without runtime errors.
5. There are no TypeScript compile errors in either `client` or `server`.
6. The repo has a clear structure and a `README.md` documenting how to install and run the project.


Please generate **all necessary code files in full** (not just descriptions), so that I can create the directory structure, paste each file where it belongs, run `npm install` as described, and immediately start the app with the single dev command.


________________


Here’s CT2 as a drop-in prompt for your autocoder 👇
CT2 – Database Schema & Data Access Layer (SQLite)


You are an expert full-stack TypeScript engineer.


The project from **CT1** already exists as a monorepo called `pdm-parris-dubbo-mover` with:


- `server/` – Node.js + Express + TypeScript backend using SQLite via `better-sqlite3` (or `sqlite3`).
- `client/` – React + TypeScript + Vite frontend.
- Working `GET /api/health` endpoint.


In this task, **do not break any existing functionality** (especially `/api/health`).  
Your job is to implement the **database schema + basic data access layer** in the backend, based on the PDM design, so future CT prompts can build APIs and UI on top.


---


## 1. Stack & assumptions


- Use the **existing SQLite setup** from CT1 (`better-sqlite3` preferred, or `sqlite3` if that’s what’s already there).
- No heavy ORM (no Prisma, no TypeORM). Use **plain SQL + small helper functions**.
- Implement a **simple migration/init system** that:
  - Runs on server startup.
  - Creates tables with `CREATE TABLE IF NOT EXISTS` statements.
  - Seeds essential baseline data (domains and a default user).


---


## 2. Tables to create (schema design)


Create these tables in SQLite, with sensible defaults and constraints.


Use **INTEGER PRIMARY KEY AUTOINCREMENT** for IDs, and **TEXT** for string-like fields. Use **ISO 8601 strings** (TEXT) for dates/datetimes (e.g. `2026-01-15T09:00:00Z` or local time).


### 2.1 `users`


Represents the (single) app user, but design for possible multi-user later.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `name` TEXT NOT NULL
- `email` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


Seed one default user:


- `id = 1`, `name = 'Josh Parris'`, `email` can be null or a placeholder.


### 2.2 `domains`


Logical groupings/modules (Housing, Health, etc.).


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `name` TEXT NOT NULL       -- Human label, e.g. "Housing & Rentals"
- `slug` TEXT NOT NULL UNIQUE  -- Machine-friendly, e.g. "housing", "health_ms"
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


Seed these records (IDs can be fixed or let AUTOINCREMENT choose, but slugs must match exactly):


1. `name = 'Housing & Rentals', slug = 'housing'`
2. `name = 'Kristy’s Work & Career', slug = 'kristy_work'`
3. `name = 'Childcare & Schooling', slug = 'childcare_schooling'`
4. `name = 'Health & MS / Neurology', slug = 'health_ms'`
5. `name = 'Josh’s Work at DCS', slug = 'dcs_work'`
6. `name = 'NDIS & Therapies (Sylvie)', slug = 'ndis_therapies'`
7. `name = 'Licensing, Rego & WWCC', slug = 'licensing_rego'`
8. `name = 'Utilities & Services', slug = 'utilities_services'`
9. `name = 'Packing, Logistics & Travel', slug = 'packing_logistics'`
10. `name = 'Church & Community', slug = 'church_community'`
11. `name = 'What Should I Do Next', slug = 'next_actions'`


### 2.3 `documents`


Uploaded docs (PDF, DOCX, images etc.) with extracted text.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `title` TEXT NOT NULL                 -- user-friendly title
- `original_filename` TEXT              -- raw filename
- `source_path` TEXT                    -- path on disk if stored locally
- `content_text` TEXT                   -- extracted text (may be large)
- `uploaded_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


No seed data required yet.


### 2.4 `properties`


Houses: Bendigo home + Dubbo rental candidates.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `address` TEXT NOT NULL
- `type` TEXT NOT NULL       -- e.g. 'bendigo_home', 'dubbo_rental_candidate', 'dubbo_rental_confirmed'
- `rent_weekly` REAL         -- weekly rent in AUD (for rentals)
- `status` TEXT              -- e.g. 'interested', 'applied', 'secured', 'handed_over'
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


Optionally seed one `properties` row for 53 Buckland St (type `bendigo_home`).


### 2.5 `job_options`


Kristy’s job options in Dubbo.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `employer` TEXT NOT NULL       -- 'Tresillian Dubbo', 'NSW Health', etc.
- `role` TEXT                    -- 'Registered Nurse', etc.
- `hours_per_week` REAL          -- approximate hours
- `pay_rate_hourly` REAL         -- approximate pay
- `status` TEXT                  -- 'idea', 'applied', 'offer', 'accepted', 'rejected'
- `pros` TEXT                    -- freeform notes
- `cons` TEXT                    -- freeform notes
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


No seed data required; will be user-entered later.


### 2.6 `childcare_options`


Daycare/preschool options for Elias and Sylvie.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `name` TEXT NOT NULL             -- 'Imagine Childcare Blueridge', etc.
- `type` TEXT NOT NULL             -- 'daycare', 'preschool', 'combined'
- `location` TEXT                  -- address or area
- `min_age_months` INTEGER         -- age eligibility
- `max_age_months` INTEGER
- `daily_fee` REAL                 -- approximate daily fee
- `status` TEXT                    -- 'idea', 'waitlisted', 'offered', 'enrolled', 'rejected'
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


### 2.7 `providers`


Generic providers: neurologists, GPs, OTs, property manager, etc.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `name` TEXT NOT NULL
- `type` TEXT NOT NULL             -- 'neurologist', 'gp', 'ot', 'speech', 'psych', 'property_manager', 'church', etc.
- `phone` TEXT
- `email` TEXT
- `address` TEXT
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


### 2.8 `appointments`


Fixed-time events: medical, psych, move-related, first day at DCS, etc.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `provider_id` INTEGER REFERENCES providers(id)
- `title` TEXT NOT NULL           -- 'Renee Matheson – Parent session', 'Tysabri infusion', etc.
- `description` TEXT
- `location` TEXT
- `start_datetime` TEXT NOT NULL
- `end_datetime` TEXT             -- optional
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


### 2.9 `trips`


High-level travel legs (e.g. Bendigo → Dubbo, Dubbo → Bendigo truck return).


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `date` TEXT NOT NULL            -- date of travel leg
- `origin` TEXT NOT NULL
- `destination` TEXT NOT NULL
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


### 2.10 `trip_assignments`


“People/vehicle matrix” rows per trip.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `trip_id` INTEGER NOT NULL REFERENCES trips(id)
- `vehicle` TEXT NOT NULL         -- 'Rental truck', 'RAV4', etc.
- `driver_name` TEXT NOT NULL
- `passengers` TEXT               -- comma-separated names is fine
- `cargo_notes` TEXT              -- e.g. 'Chooks, kids gear'
- `misc_notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


### 2.11 `tasks`


Central task/checklist table.


Fields:


- `id` INTEGER PRIMARY KEY AUTOINCREMENT
- `user_id` INTEGER NOT NULL REFERENCES users(id)
- `domain_id` INTEGER NOT NULL REFERENCES domains(id)
- `title` TEXT NOT NULL            -- short label: 'Book removalist'
- `description` TEXT               -- more detail
- `status` TEXT NOT NULL           -- 'pending', 'in_progress', 'done', 'blocked'
- `priority` INTEGER NOT NULL      -- 1=low, 2=normal, 3=high (or similar)
- `due_date` TEXT                  -- nullable
- `origin_doc_id` INTEGER REFERENCES documents(id)
- `related_property_id` INTEGER REFERENCES properties(id)
- `related_job_id` INTEGER REFERENCES job_options(id)
- `related_provider_id` INTEGER REFERENCES providers(id)
- `related_childcare_id` INTEGER REFERENCES childcare_options(id)
- `related_trip_id` INTEGER REFERENCES trips(id)
- `notes` TEXT
- `created_at` TEXT NOT NULL
- `updated_at` TEXT NOT NULL


Make sure foreign key constraints are enabled (PRAGMA foreign_keys = ON).


---


## 3. Migration/init system


In `server/`, add a simple migration/init mechanism so the schema is created automatically.


### 3.1 Files & structure


Create or update:


- `server/src/db/index.ts` – DB connection and init entrypoint.
- `server/src/db/schema.ts` – SQL `CREATE TABLE` statements + seed inserts.
- `server/src/db/migrate.ts` – function to run schema + seed logic.


**`server/src/db/index.ts`**


- Export:
  - `getDb()` – returns a singleton SQLite DB connection object.
  - `initDb()` – runs migrations on startup (calling functions from `schema.ts` / `migrate.ts`).


**`server/src/db/schema.ts`**


- Define a function `createTables(db)` that:
  - Executes `CREATE TABLE IF NOT EXISTS ...` statements for every table above, in a safe order (users → domains → others).
- Define a function `seedBaseData(db)` that:
  - Inserts default user `id=1` if no users exist.
  - Inserts domain records if the `domains` table is empty.
  - Optionally inserts a Bendigo property row for `53 Buckland St` with type `bendigo_home`.


**`server/src/db/migrate.ts`**


- Export a function `runMigrations()` that:
  - Calls `getDb()`.
  - Wraps `createTables` and `seedBaseData` in a transaction if possible.
  - Logs success or throws on error.


### 3.2 Server startup integration


In `server/src/index.ts` (or wherever the Express app is started):


- Import `initDb` or `runMigrations` from `db/index` or `db/migrate`.
- Before starting the HTTP server, call `initDb()` (or `runMigrations()`).
- If migration fails, log the error and **do not** start the server.


Example (pseudocode, you generate real TS):


```ts
import { getDb } from './db';
import { runMigrations } from './db/migrate';


// ...


async function start() {
  const db = getDb();
  await runMigrations();
  app.listen(PORT, () => {
    console.log(`Server listening on http://localhost:${PORT}`);
  });
}


start().catch((err) => {
  console.error('Failed to start server', err);
  process.exit(1);
});


________________


4. TypeScript entity types
Create a shared type file in the server:
* server/src/types/entities.ts

Define interfaces matching the schema (used by the data access layer and later by route handlers). Example (you fill in all):
export interface User {
  id: number;
  name: string;
  email: string | null;
  created_at: string;
  updated_at: string;
}


export interface Domain {
  id: number;
  name: string;
  slug: string;
  created_at: string;
  updated_at: string;
}


// Task, Property, JobOption, ChildcareOption, Provider, Appointment, Trip, TripAssignment, Document...


Use these types in the query helper functions (below).
________________


5. Basic data access helpers
Create server/src/db/queries.ts with small, reusable helpers. Use the DB connection from getDb() and the types from entities.ts.
Implement at least:
// Domains
export async function getAllDomains(): Promise<Domain[]>;


// Tasks
export interface NewTaskInput {
  user_id: number;
  domain_id: number;
  title: string;
  description?: string;
  priority?: number;      // default 2
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string;
}


export async function createTask(input: NewTaskInput): Promise<Task>;
export async function getTaskById(id: number): Promise<Task | null>;
export async function getTasksByDomain(domainSlugOrId: string | number): Promise<Task[]>;
export async function updateTaskStatus(id: number, status: Task['status']): Promise<Task>;
export async function deleteTask(id: number): Promise<void>;


Implementation notes:
   * When domainSlugOrId is a string, treat it as domains.slug and join accordingly.

   * Ensure default values:

      * status default 'pending'

      * priority default 2

      * created_at / updated_at default to current ISO timestamp.

         * Handle “not found” gracefully (e.g. return null from getTaskById).

For this CT2, you do not need to implement REST endpoints beyond what exists. These helpers will be used by future CT prompts to implement /api/tasks, /api/domains, etc.
________________


6. Scripts
Update server/package.json to add:
            * "db:migrate": "ts-node src/db/migrate.ts" (or equivalent based on how CT1 is set up).

Update the root README.md to mention:
               * npm run dev – still starts server + client.

               * npm run dev:server – still runs server only.

               * npm run db:migrate – optional explicit migrations run (though they also run on startup).

________________


7. Acceptance criteria
CT2 is complete when:
                  1. On server startup, the SQLite DB file is created (if not already) and all tables above exist.

                  2. The migration/init logic runs idempotently:

                     * Starting the server multiple times does NOT recreate or duplicate seed data.

                        3. A single user record and the full set of domains rows exist after first run.

                        4. There are no TypeScript compile errors in the server code.

                        5. The existing /api/health endpoint still works exactly as before.

                        6. The helper functions in db/queries.ts can be imported and used without runtime errors (e.g. you can briefly test them in a small test script or log from server startup).

Please generate all necessary code files in full, with correct imports/exports, so that I can:
                           * Create/update the files in server/src/db and server/src/types.

                           * Run npm install if new dependencies were added.

                           * Run npm run dev and see the app start successfully, with the DB schema created behind the scenes.



:contentReference[oaicite:0]{index=0}




________________

Nice, let’s level it up. Here’s CT3 ready to paste into Cursor / VS Code 👇
CT3 – Domains & Tasks REST API (Backend Only)


You are an expert TypeScript + Node.js engineer.


The existing project `pdm-parris-dubbo-mover` already has:


- `server/` – Node + Express + TypeScript backend with SQLite (via better-sqlite3 or sqlite3).
- `server/src/db` – DB connection + migrations from CT2 (including `users`, `domains`, `tasks`, etc.).
- `server/src/types/entities.ts` – TypeScript interfaces for DB entities.
- `server/src/db/queries.ts` – Basic helpers including `getAllDomains`, `createTask`, etc.
- `client/` – React + TS + Vite frontend (no tasks UI yet).
- A working `GET /api/health` endpoint.


In **CT3**, do **not** break any of the existing endpoints or schema.


Your job:  
Implement a clean **REST API** for **Domains** and **Tasks** in the backend, to support the PDM modules described in the design blueprint (domains like “housing”, “health_ms”, “packing_logistics”, etc.) and the central task/checklist system. :contentReference[oaicite:0]{index=0}  


No frontend changes yet – just backend routes, wired to the existing DB + query helpers.


---


## 1. Backend file & folder structure


Work only in `server/` for this task.


Create/ensure this structure:


- `server/src/app.ts`          – main Express app (already exists from CT1).
- `server/src/index.ts`        – server startup (already exists).
- `server/src/routes/`
  - `health.ts`                – existing health route
  - `domains.ts`               – NEW
  - `tasks.ts`                 – NEW
- `server/src/db/`
  - `index.ts` / `migrate.ts` / `schema.ts` (from CT2)
  - `queries.ts`               – already exists, will be extended if needed
- `server/src/types/entities.ts` – already exists, may be extended


Wire the new routers into `app.ts`.


---


## 2. Domain & Task TypeScript models (server types)


In `server/src/types/entities.ts`, ensure the following interfaces are defined (extend or adjust existing ones as needed to match CT2 schema):


```ts
export interface Domain {
  id: number;
  name: string;
  slug: string;
  created_at: string;
  updated_at: string;
}


export type TaskStatus = 'pending' | 'in_progress' | 'done' | 'blocked';


export interface Task {
  id: number;
  user_id: number;
  domain_id: number;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: number; // 1=low, 2=normal, 3=high
  due_date: string | null;
  origin_doc_id: number | null;
  related_property_id: number | null;
  related_job_id: number | null;
  related_provider_id: number | null;
  related_childcare_id: number | null;
  related_trip_id: number | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
}


If any field names differ from CT2, align them with the actual DB schema defined there (keep consistency between schema, queries, and types).
Also declare a server-side DTO for task creation/update (in a new file or in queries.ts):
export interface NewTaskInput {
  user_id: number;
  domain_id: number;
  title: string;
  description?: string;
  priority?: number;
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string;
}


export interface UpdateTaskInput {
  title?: string;
  description?: string | null;
  status?: TaskStatus;
  priority?: number;
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string | null;
}


________________


3. Data access helpers (extend db/queries.ts)
If not already implemented in CT2, implement/complete these helper functions using the SQLite DB connection from getDb():
import type { Domain, Task, TaskStatus } from '../types/entities';
import type { NewTaskInput, UpdateTaskInput } from '../types/entities-or-dtos';


// Domains
export async function getAllDomains(): Promise<Domain[]>;


// Tasks
export async function createTask(input: NewTaskInput): Promise<Task>;


export async function getTaskById(id: number): Promise<Task | null>;


export async function getTasks(params: {
  domainId?: number;
  domainSlug?: string;
  status?: TaskStatus;
  dueBefore?: string; // ISO date
  limit?: number;
}): Promise<Task[]>;


export async function updateTask(id: number, input: UpdateTaskInput): Promise<Task | null>;


export async function deleteTask(id: number): Promise<void>;


Implementation details:
                              * For getTasks:

                                 * Build a SQL SELECT with optional filters:

                                    * If domainId is provided, filter by tasks.domain_id = ?.

                                    * If domainSlug is provided, join to domains on domains.id = tasks.domain_id and filter by domains.slug = ?.

                                    * If status is provided, filter by tasks.status = ?.

                                    * If dueBefore is provided, filter tasks.due_date IS NOT NULL AND tasks.due_date <= ?.

                                    * If limit is provided, LIMIT ? (default 100).

                                       * Order by due_date ascending, then priority descending, then created_at ascending.

                                          * For createTask:

                                             * Set defaults:

                                                * status = 'pending'

                                                * priority = 2 if not provided

                                                * created_at/updated_at = current ISO string.

                                                   * Insert and return the full created row.

                                                      * For updateTask:

                                                         * Only update the fields present in input.

                                                         * Always update updated_at.

                                                         * Return null if the task doesn’t exist.

                                                            * Enable foreign keys (PRAGMA foreign_keys = ON) in the DB connection (if not already done).

Use synchronous DB calls if you’re using better-sqlite3, but still wrap them in async functions so the rest of the app can use await.
________________


4. Express routes – Domains (routes/domains.ts)
Create server/src/routes/domains.ts:
                                                               * Import Router from express and getAllDomains from db/queries.

                                                               * Define:

import { Router } from 'express';
import { getAllDomains } from '../db/queries';


const router = Router();


// GET /api/domains
router.get('/', async (req, res, next) => {
  try {
    const domains = await getAllDomains();
    res.json(domains);
  } catch (err) {
    next(err);
  }
});


export default router;


In server/src/app.ts, mount this router under /api/domains:
import domainsRouter from './routes/domains';
// ...
app.use('/api/domains', domainsRouter);


________________


5. Express routes – Tasks (routes/tasks.ts)
Create server/src/routes/tasks.ts:
5.1 Validation helper
Inside tasks.ts, write a small helper to validate incoming data:
function isValidStatus(status: any): status is TaskStatus {
  return ['pending', 'in_progress', 'done', 'blocked'].includes(status);
}


function parseIntOrUndefined(value: any): number | undefined {
  if (value === undefined) return undefined;
  const n = Number(value);
  return Number.isNaN(n) ? undefined : n;
}


5.2 Routes to implement
Mount these paths under /api/tasks in app.ts.
GET /api/tasks
                                                                  * Supports query parameters:

                                                                     * domainId (number)

                                                                     * domainSlug (string)

                                                                     * status (TaskStatus)

                                                                     * dueBefore (ISO date string)

                                                                     * limit (number)

                                                                        * Use getTasks({ ... }) to fetch.

                                                                        * Return JSON array of tasks.

Example handler:
router.get('/', async (req, res, next) => {
  try {
    const domainId = parseIntOrUndefined(req.query.domainId);
    const domainSlug = typeof req.query.domainSlug === 'string' ? req.query.domainSlug : undefined;
    const status = typeof req.query.status === 'string' && isValidStatus(req.query.status)
      ? req.query.status
      : undefined;
    const dueBefore = typeof req.query.dueBefore === 'string' ? req.query.dueBefore : undefined;
    const limit = parseIntOrUndefined(req.query.limit);


    const tasks = await getTasks({ domainId, domainSlug, status, dueBefore, limit });
    res.json(tasks);
  } catch (err) {
    next(err);
  }
});


GET /api/tasks/:id
                                                                           * Parse id from path.

                                                                           * Use getTaskById(id).

                                                                           * If not found, return 404 with { error: 'Task not found' }.

POST /api/tasks
                                                                              * Expect JSON body with at least:

                                                                                 * domain_id (number) OR a domain_slug (string, e.g. "housing").

                                                                                 * title (string, non-empty).

                                                                                    * Optional:

                                                                                       * description, priority, due_date, origin_doc_id, related_* fields, notes.

                                                                                          * Assume user_id = 1 for now (single-user; later auth can override).

                                                                                          * If domain_slug is provided instead of domain_id:

                                                                                             * Look up the domains table to find the ID; if not found, return 400.

                                                                                                * Validate:

                                                                                                   * title is non-empty string.

                                                                                                   * priority if provided is 1, 2, or 3.

                                                                                                   * due_date if provided is a string; do not over-validate the format, but if it’s obviously invalid (empty string), reject.

                                                                                                      * Call createTask and return 201 with the created task.

PATCH /api/tasks/:id
Allow partial updates. Body may include any subset of:

{
  title?: string;
  description?: string | null;
  status?: TaskStatus;
  priority?: number;
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string | null;
}
                                                                                                         *                                                                                                          * Validate status (using isValidStatus) and priority (1–3).

                                                                                                         * Call updateTask(id, updateInput).

                                                                                                         * If result is null, return 404. Otherwise return the updated task.

DELETE /api/tasks/:id
                                                                                                            * Call deleteTask(id).

                                                                                                            * If the task didn’t exist, you may treat it as idempotent and still return 204, or check and return 404. Either is acceptable; pick one and implement consistently.

                                                                                                            * On success, return 204 No Content.

5.3 Mounting in app.ts
In server/src/app.ts:
import tasksRouter from './routes/tasks';


// after `app.use(express.json())`, etc.
app.use('/api/tasks', tasksRouter);


Ensure error-handling middleware is present at the bottom of app.ts to catch thrown errors and return a JSON response (e.g. 500).
________________


6. README – API documentation
In the root README.md, add a short “API Overview” section describing the new endpoints:
                                                                                                               * GET /api/domains – list of domains.

                                                                                                               * GET /api/tasks – list tasks; mention query params domainId, domainSlug, status, dueBefore, limit.

                                                                                                               * GET /api/tasks/:id

                                                                                                               * POST /api/tasks

                                                                                                               * PATCH /api/tasks/:id

                                                                                                               * DELETE /api/tasks/:id

Include a quick example of creating a task via curl:
curl -X POST http://localhost:4000/api/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "domain_slug": "housing",
    "title": "Book rental appraisal with Yolena",
    "priority": 3,
    "due_date": "2025-11-30T00:00:00"
  }'


(or the correct port if you expose APIs through the Vite proxy).
________________


7. Acceptance criteria
CT3 is complete when:
                                                                                                                  1. The server still starts successfully via the existing root npm run dev command.

                                                                                                                  2. GET /api/domains returns the seeded domains from CT2 (e.g. housing, childcare_schooling, health_ms, etc.).

                                                                                                                  3. POST /api/tasks with a minimal valid body (domain + title) returns 201 and the created task.

                                                                                                                  4. GET /api/tasks returns a list including the created task; filtering by domainSlug and status works as expected.

                                                                                                                  5. PATCH /api/tasks/:id can update the task’s status to 'done' and returns the updated task.

                                                                                                                  6. DELETE /api/tasks/:id removes the task and subsequent GET /api/tasks/:id returns 404.

                                                                                                                  7. All new server code type-checks (no TypeScript errors) and passes a quick manual test via curl/Postman or browser (using the dev proxy at http://localhost:3000/api/... if configured).

Please output all new/changed files in full (or clearly indicate full contents vs modifications), so I can copy/paste into the server folder and immediately use the new API.
________________


Here’s CT4 ready to paste into Cursor / VS Code 👇
CT4 – Frontend Domains & Tasks UI (React Client)


You are an expert React + TypeScript engineer.


The existing project `pdm-parris-dubbo-mover` already has:


- `client/` – React + TypeScript + Vite app.
- `server/` – Node + Express + TypeScript backend with:
  - SQLite schema (users, domains, tasks, etc.) from CT2.
  - REST API from CT3:
    - `GET /api/domains`
    - `GET /api/tasks` (+ filters)
    - `GET /api/tasks/:id`
    - `POST /api/tasks`
    - `PATCH /api/tasks/:id`
    - `DELETE /api/tasks/:id`
- Vite dev server proxy so `client` can hit `/api/...` without CORS problems.
- A home page that currently just shows “PDM App running” and calls `/api/health`.


Do **not** break any existing behaviour.  
Your job in CT4: implement a **basic but solid Domains + Tasks UI** so the user can:


- See all domains (e.g. “Housing & Rentals”, “Childcare & Schooling”, “Health & MS”, etc.).
- Select a domain.
- View tasks for that domain.
- Create, update, and delete tasks via the existing API.


We’re aiming for a clean foundation, not perfect styling yet.


---


## 1. Client-side API layer


In `client/src/`, create a small, typed API helper layer for domains and tasks.


### 1.1 Types


Create a file `client/src/types/api.ts` with:


```ts
export interface Domain {
  id: number;
  name: string;
  slug: string;
  created_at: string;
  updated_at: string;
}


export type TaskStatus = 'pending' | 'in_progress' | 'done' | 'blocked';


export interface Task {
  id: number;
  user_id: number;
  domain_id: number;
  title: string;
  description: string | null;
  status: TaskStatus;
  priority: number; // 1=low, 2=normal, 3=high
  due_date: string | null;
  origin_doc_id: number | null;
  related_property_id: number | null;
  related_job_id: number | null;
  related_provider_id: number | null;
  related_childcare_id: number | null;
  related_trip_id: number | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
}


export interface NewTaskPayload {
  domain_id?: number;
  domain_slug?: string;
  title: string;
  description?: string;
  priority?: number;
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string;
}


export interface UpdateTaskPayload {
  title?: string;
  description?: string | null;
  status?: TaskStatus;
  priority?: number;
  due_date?: string | null;
  origin_doc_id?: number | null;
  related_property_id?: number | null;
  related_job_id?: number | null;
  related_provider_id?: number | null;
  related_childcare_id?: number | null;
  related_trip_id?: number | null;
  notes?: string | null;
}


Match field names exactly to what the backend returns (from CT3).
1.2 API helpers
Create client/src/api/client.ts:
                                                                                                                     * Implement a thin wrapper around fetch that:

                                                                                                                        * Uses window.fetch.

                                                                                                                        * Automatically JSON-encodes bodies for non-GET requests.

                                                                                                                        * Throws on non-2xx responses with useful error info.

Example structure (you generate full code):
const API_BASE = ''; // empty, rely on Vite proxy so `/api/...` works


async function apiRequest<T>(path: string, options: RequestInit = {}): Promise<T> {
  const res = await fetch(API_BASE + path, {
    headers: {
      'Content-Type': 'application/json',
      ...(options.headers || {}),
    },
    ...options,
  });


  if (!res.ok) {
    let message = `Request failed with status ${res.status}`;
    try {
      const data = await res.json();
      if (data && typeof data.error === 'string') {
        message = data.error;
      }
    } catch {
      // ignore
    }
    throw new Error(message);
  }


  if (res.status === 204) {
    return undefined as unknown as T;
  }


  return res.json() as Promise<T>;
}


export { apiRequest };


Create client/src/api/domains.ts and client/src/api/tasks.ts:
// domains.ts
import { apiRequest } from './client';
import type { Domain } from '../types/api';


export async function fetchDomains(): Promise<Domain[]> {
  return apiRequest<Domain[]>('/api/domains');
}


// tasks.ts
import { apiRequest } from './client';
import type { Task, NewTaskPayload, UpdateTaskPayload, TaskStatus } from '../types/api';


export interface TaskQueryParams {
  domainId?: number;
  domainSlug?: string;
  status?: TaskStatus;
  dueBefore?: string;
  limit?: number;
}


export async function fetchTasks(params: TaskQueryParams = {}): Promise<Task[]> {
  const searchParams = new URLSearchParams();
  if (params.domainId != null) searchParams.set('domainId', String(params.domainId));
  if (params.domainSlug) searchParams.set('domainSlug', params.domainSlug);
  if (params.status) searchParams.set('status', params.status);
  if (params.dueBefore) searchParams.set('dueBefore', params.dueBefore);
  if (params.limit != null) searchParams.set('limit', String(params.limit));


  const query = searchParams.toString();
  const path = query ? `/api/tasks?${query}` : '/api/tasks';
  return apiRequest<Task[]>(path);
}


export async function createTask(payload: NewTaskPayload): Promise<Task> {
  return apiRequest<Task>('/api/tasks', {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}


export async function updateTask(id: number, payload: UpdateTaskPayload): Promise<Task> {
  return apiRequest<Task>(`/api/tasks/${id}`, {
    method: 'PATCH',
    body: JSON.stringify(payload),
  });
}


export async function deleteTask(id: number): Promise<void> {
  return apiRequest<void>(`/api/tasks/${id}`, {
    method: 'DELETE',
  });
}


________________


2. Layout & Navigation
Update the main app layout so it feels like a small “mission control” for tasks.
2.1 App shell
In client/src/App.tsx:
                                                                                                                           * Use react-router-dom’s <BrowserRouter> around the app.

                                                                                                                           * Create routes:

                                                                                                                              * / – “Dashboard” (for now just show a welcome and maybe a summary of domain counts later).

                                                                                                                              * /tasks – Domains + Tasks screen (main focus of CT4).

                                                                                                                                 * Add a very simple navigation header (no heavy styling needed):

                                                                                                                                    * App title: “ParrisDubboMover (PDM)”.

                                                                                                                                    * Links: “Dashboard”, “Tasks”.

Example (you write real TSX):
return (
  <BrowserRouter>
    <div className="app-shell">
      <header>...</header>
      <main>
        <Routes>
          <Route path="/" element={<DashboardPage />} />
          <Route path="/tasks" element={<TasksPage />} />
        </Routes>
      </main>
    </div>
  </BrowserRouter>
);


Create client/src/pages/DashboardPage.tsx and client/src/pages/TasksPage.tsx.
                                                                                                                                       * DashboardPage can be very simple for now (e.g. “PDM App running – Dashboard”).

                                                                                                                                       * TasksPage will host the new UI.

________________


3. Tasks Page UI
The Tasks page should have:
                                                                                                                                          * Left pane: list of domains.

                                                                                                                                          * Right pane: tasks for the selected domain, with basic CRUD.

3.1 Domain list (left pane)
Create a component client/src/components/DomainList.tsx:
Props:
interface DomainListProps {
  domains: Domain[];
  selectedDomainId: number | null;
  onSelectDomain: (domain: Domain) => void;
}


Behaviour:
                                                                                                                                             * Render a vertical list of buttons or clickable items for each domain.

                                                                                                                                             * Highlight the currently selected domain.

                                                                                                                                             * When a domain is clicked, call onSelectDomain(domain).

Styling can be simple:
                                                                                                                                                * Left column ~250px wide.

                                                                                                                                                * Right column fills the rest.

3.2 Task list & controls (right pane)
Create client/src/components/TaskList.tsx:
Props:
interface TaskListProps {
  tasks: Task[];
  onEditTask: (task: Task) => void;
  onDeleteTask: (task: Task) => void;
  onToggleStatus: (task: Task) => void; // e.g. pending <-> done
}


Behaviour:
                                                                                                                                                   * Display tasks in a table or list; show:

                                                                                                                                                      * Title

                                                                                                                                                      * Status (with a small badge or text)

                                                                                                                                                      * Priority (1/2/3 → maybe Low/Normal/High)

                                                                                                                                                      * Due date (formatted, or “–”)

                                                                                                                                                         * For each task, show action buttons:

                                                                                                                                                            * “Edit”

                                                                                                                                                            * “Delete”

                                                                                                                                                            * “Toggle Done” (e.g. if status is done, set it back to pending, otherwise set to done).

3.3 Task create/edit form
Create client/src/components/TaskFormModal.tsx (or TaskForm.tsx with a simple overlay):
Props:
interface TaskFormModalProps {
  open: boolean;
  mode: 'create' | 'edit';
  initialTask?: Task;
  domain: Domain | null;
  onCancel: () => void;
  onSubmit: (data: { title: string; description: string; priority: number; due_date: string | null; }) => void;
}


Behaviour:
                                                                                                                                                               * If open is false, render null.

                                                                                                                                                               * If open is true:

                                                                                                                                                                  * Show a simple overlay / modal (can be pure CSS with a fixed position).

                                                                                                                                                                  * Fields:

                                                                                                                                                                     * Title (required)

                                                                                                                                                                     * Description (textarea)

                                                                                                                                                                     * Priority (select with 1/2/3 and labels)

                                                                                                                                                                     * Due date (input type="date"; convert to ISO date string on submit like YYYY-MM-DDT00:00:00 or just YYYY-MM-DD consistently).

                                                                                                                                                                        * When in edit mode:

                                                                                                                                                                           * Pre-fill fields from initialTask.

                                                                                                                                                                              * On submit:

                                                                                                                                                                                 * Validate that title is non-empty.

                                                                                                                                                                                 * Call onSubmit(...).

No need for fancy libraries – just use React state and basic HTML inputs.
________________


4. Wiring it together in TasksPage
In client/src/pages/TasksPage.tsx:
State:
                                                                                                                                                                                    * domains: Domain[]

                                                                                                                                                                                    * selectedDomain: Domain | null

                                                                                                                                                                                    * tasks: Task[]

                                                                                                                                                                                    * loadingDomains: boolean

                                                                                                                                                                                    * loadingTasks: boolean

                                                                                                                                                                                    * error: string | null

                                                                                                                                                                                    * isFormOpen: boolean

                                                                                                                                                                                    * formMode: 'create' | 'edit'

                                                                                                                                                                                    * editingTask: Task | null

Effects:
                                                                                                                                                                                       1. On mount:

                                                                                                                                                                                          * Fetch domains via fetchDomains().

                                                                                                                                                                                          * Set the first domain as selectedDomain by default (if any).

                                                                                                                                                                                             2. Whenever selectedDomain changes:

                                                                                                                                                                                                * Fetch tasks for that domain via fetchTasks({ domainId: selectedDomain.id }).

Handlers:
                                                                                                                                                                                                   * handleSelectDomain(domain: Domain):

                                                                                                                                                                                                      * Set selectedDomain.

                                                                                                                                                                                                      * Clear existing tasks or set to loading; trigger fetch.

                                                                                                                                                                                                         * handleOpenCreateTask():

                                                                                                                                                                                                            * Only if selectedDomain is not null.

                                                                                                                                                                                                            * Set formMode = 'create', editingTask = null, isFormOpen = true.

                                                                                                                                                                                                               * handleOpenEditTask(task: Task):

                                                                                                                                                                                                                  * Set formMode = 'edit', editingTask = task, isFormOpen = true.

                                                                                                                                                                                                                     * handleSubmitTask(formData):

                                                                                                                                                                                                                        * If formMode === 'create' and selectedDomain is set:

                                                                                                                                                                                                                           * Call createTask({ domain_id: selectedDomain.id, ...mappedFormData }).

                                                                                                                                                                                                                           * On success, close modal and refresh tasks for this domain.

                                                                                                                                                                                                                              * If formMode === 'edit' and editingTask exists:

                                                                                                                                                                                                                                 * Call updateTask(editingTask.id, mappedFormData).

                                                                                                                                                                                                                                 * On success, close modal and refresh tasks.

                                                                                                                                                                                                                                    * Handle errors by setting error and displaying a simple message.

                                                                                                                                                                                                                                       * handleToggleStatus(task: Task):

                                                                                                                                                                                                                                          * Compute new status:

                                                                                                                                                                                                                                             * If task.status === 'done', set to 'pending'.

                                                                                                                                                                                                                                             * Else set to 'done'.

                                                                                                                                                                                                                                                * Call updateTask(task.id, { status: newStatus }).

                                                                                                                                                                                                                                                * On success, update the tasks list in state (or re-fetch).

                                                                                                                                                                                                                                                   * handleDeleteTask(task: Task):

                                                                                                                                                                                                                                                      * Confirm with window.confirm.

                                                                                                                                                                                                                                                      * Call deleteTask(task.id).

                                                                                                                                                                                                                                                      * On success, remove from state or re-fetch.

UI structure:
Show a 2-column layout:

<div className="tasks-page">
  <div className="tasks-layout">
    <aside className="tasks-domains-column">
      {/* DomainList */}
    </aside>
    <section className="tasks-main-column">
      {/* Selected domain title */}
      {/* New Task button */}
      {/* TaskList */}
    </section>
  </div>
</div>
                                                                                                                                                                                                                                                         *                                                                                                                                                                                                                                                          * If there are no domains:

                                                                                                                                                                                                                                                            * Show a message like “No domains available – check backend seed data.”

                                                                                                                                                                                                                                                               * Show loading indicators and simple error messages where appropriate.

________________


5. Basic styling
In client/src/index.css (or similar global stylesheet):
                                                                                                                                                                                                                                                                  * Implement minimal layout styles:

                                                                                                                                                                                                                                                                     * App shell with header and main.

                                                                                                                                                                                                                                                                     * Tasks page with two columns using CSS grid or flexbox.

                                                                                                                                                                                                                                                                        * Keep it simple and readable:

                                                                                                                                                                                                                                                                           * Left sidebar: narrow, light background.

                                                                                                                                                                                                                                                                           * Right content: main area.

                                                                                                                                                                                                                                                                              * No need for Tailwind, MUI, etc. unless they already exist – plain CSS is fine.

________________


6. README update
In the root README.md, add a short section:
                                                                                                                                                                                                                                                                                 * “Tasks UI”:

                                                                                                                                                                                                                                                                                    * Explain that visiting /tasks in the browser:

                                                                                                                                                                                                                                                                                       * Shows domain list on the left.

                                                                                                                                                                                                                                                                                       * Allows selecting a domain and managing tasks for that domain.

________________


________________
7. Acceptance criteria
CT4 is complete when:
                                                                                                                                                                                                                                                                                          1. npm run dev from the repo root still starts both backend and frontend successfully.

                                                                                                                                                                                                                                                                                          2. Visiting http://localhost:3000/tasks shows:

                                                                                                                                                                                                                                                                                             * A list of domains on the left (from GET /api/domains).

                                                                                                                                                                                                                                                                                             * When a domain is selected, a list of tasks for that domain (from GET /api/tasks?domainId=...).

                                                                                                                                                                                                                                                                                                3. The user can:

                                                                                                                                                                                                                                                                                                   * Create a new task for the selected domain via a form.

                                                                                                                                                                                                                                                                                                   * Edit an existing task’s title/description/priority/due date.

                                                                                                                                                                                                                                                                                                   * Toggle task status between pending and done.

                                                                                                                                                                                                                                                                                                   * Delete a task.

                                                                                                                                                                                                                                                                                                      4. All operations use the existing REST API from CT3, and changes persist in SQLite.

                                                                                                                                                                                                                                                                                                      5. There are no TypeScript errors in the client, and the UI behaves reasonably on a laptop and a phone-width viewport (simple responsive layout is enough).

Please output all new/changed files (TSX, TS, CSS) in full, with correct imports and exports, so I can copy them into client/src and have a working Domains + Tasks UI.
________________


CT5 – Document Upload, Storage & Basic Document Browser (Backend + Frontend)


You are an expert full-stack TypeScript engineer.


The existing project `pdm-parris-dubbo-mover` already has:


- `server/` – Node + Express + TypeScript backend with:
  - SQLite schema including a `documents` table (from CT2).
  - DB helpers and a tasks/domains REST API (from CT3).
- `client/` – React + TypeScript + Vite frontend with:
  - Basic app shell and navigation.
  - Tasks UI (domains + tasks) from CT4.
- Vite dev server proxy so `/api/...` is proxied to the backend.


Do **not** break any existing behaviour.


Your job in CT5: implement **document upload + basic document browser**, so the user can:


- Upload PDFs/DOCX/TXT (and optionally images for now, stored but with no OCR).
- Store them in the `documents` table and on disk.
- View a list of uploaded documents.
- Click a document to see metadata and a preview of extracted text.


This will later be used to generate tasks and “what next” suggestions.


---


## 1. Backend – File upload & document APIs


Work in `server/`.


### 1.1 Dependencies


Add to `server/package.json`:


- For parsing multipart/form-data:
  - `multer`
- For text extraction:
  - `pdf-parse` for PDFs
  - `mammoth` for DOCX
- (Optional) Fallback: treat `.txt` as plain text; `.docx` via `mammoth`; unknown binaries stored with empty `content_text` for now.


Add `@types/multer` to devDependencies.


Run `npm install` according to your normal workflow.


### 1.2 Directory for uploads


In `server/`:


- Create a folder `uploads/` at the project root of `server` (sibling of `src/`), and ensure it is used to store uploaded files.
- Update `.gitignore` (either root or server-level) to ignore `server/uploads` contents, except maybe a `.gitkeep` if needed.


### 1.3 DB helper for documents


Extend `server/src/types/entities.ts`:


```ts
export interface Document {
  id: number;
  user_id: number;
  title: string;
  original_filename: string | null;
  source_path: string | null;
  content_text: string | null;
  uploaded_at: string;
  updated_at: string;
}


Match the actual schema created in CT2.
In server/src/db/queries.ts, add:
import type { Document } from '../types/entities';


export interface NewDocumentInput {
  user_id: number;
  title: string;
  original_filename?: string | null;
  source_path?: string | null;
  content_text?: string | null;
}


export async function createDocument(input: NewDocumentInput): Promise<Document>;


export async function getDocumentById(id: number): Promise<Document | null>;


export async function listDocuments(params?: {
  limit?: number;
  search?: string; // search in title or content_text
}): Promise<Document[]>;


Implementation notes:
                                                                                                                                                                                                                                                                                                         * createDocument:

                                                                                                                                                                                                                                                                                                            * Set uploaded_at and updated_at to current ISO string.

                                                                                                                                                                                                                                                                                                            * Insert into documents and return the full row.

                                                                                                                                                                                                                                                                                                               * getDocumentById:

                                                                                                                                                                                                                                                                                                                  * SELECT * FROM documents WHERE id = ?.

                                                                                                                                                                                                                                                                                                                     * listDocuments:

                                                                                                                                                                                                                                                                                                                        * If search is provided, filter with a LIKE on title OR content_text (e.g. %search%).

                                                                                                                                                                                                                                                                                                                        * Limit results (default 100 if no limit given).

                                                                                                                                                                                                                                                                                                                        * Order by uploaded_at DESC.

1.4 Text extraction helpers
Create a new file server/src/services/documentTextExtractor.ts:
Implement functions:
import fs from 'fs';
import path from 'path';
import pdfParse from 'pdf-parse';
import mammoth from 'mammoth';


export async function extractTextFromFile(filePath: string, mimeType?: string, originalFilename?: string): Promise<string> {
  const ext = (originalFilename || '').toLowerCase();


  if (mimeType === 'application/pdf' || ext.endsWith('.pdf')) {
    return extractPdfText(filePath);
  }


  if (
    mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
    ext.endsWith('.docx')
  ) {
    return extractDocxText(filePath);
  }


  if (mimeType === 'text/plain' || ext.endsWith('.txt')) {
    return extractTxtText(filePath);
  }


  // For unsupported types (e.g., images), just return empty string for now.
  return '';
}


async function extractPdfText(filePath: string): Promise<string> {
  const data = await fs.promises.readFile(filePath);
  const result = await pdfParse(data);
  return result.text || '';
}


async function extractDocxText(filePath: string): Promise<string> {
  const result = await mammoth.extractRawText({ path: filePath });
  return result.value || '';
}


async function extractTxtText(filePath: string): Promise<string> {
  const data = await fs.promises.readFile(filePath, 'utf8');
  return data.toString();
}


Handle errors gracefully in the calling code (if extraction fails, log and proceed with empty content_text).
1.5 Express routes – /api/documents
Create server/src/routes/documents.ts:
                                                                                                                                                                                                                                                                                                                           * Use multer for file upload.

                                                                                                                                                                                                                                                                                                                           * Add routes:

POST /api/documents/upload
                                                                                                                                                                                                                                                                                                                              * Accept multipart/form-data with:

                                                                                                                                                                                                                                                                                                                                 1. Field name: file (single file).

                                                                                                                                                                                                                                                                                                                                 2. Optional text fields:

                                                                                                                                                                                                                                                                                                                                    * title (string); if not provided, default to the original filename.

                                                                                                                                                                                                                                                                                                                                    * user_id (ignore for now; default to 1).

                                                                                                                                                                                                                                                                                                                                       * Validate:

                                                                                                                                                                                                                                                                                                                                          1. If no file, return 400 with { error: 'File is required' }.

                                                                                                                                                                                                                                                                                                                                             * On success:

                                                                                                                                                                                                                                                                                                                                                1. Save the file to server/uploads/<timestamp>_<originalname>.

                                                                                                                                                                                                                                                                                                                                                2. Extract text via extractTextFromFile(filePath, mimeType, originalFilename).

                                                                                                                                                                                                                                                                                                                                                3. Call createDocument with:

                                                                                                                                                                                                                                                                                                                                                   * user_id = 1

                                                                                                                                                                                                                                                                                                                                                   * title from field or filename

                                                                                                                                                                                                                                                                                                                                                   * original_filename

                                                                                                                                                                                                                                                                                                                                                   * source_path as the relative path, e.g. uploads/<timestamp>_<originalname>

                                                                                                                                                                                                                                                                                                                                                   * content_text as extraction result (string; you may truncate if extremely large, but no need yet).

                                                                                                                                                                                                                                                                                                                                                      4. Return 201 with the created document JSON.

GET /api/documents
                                                                                                                                                                                                                                                                                                                                                         * Query params:

                                                                                                                                                                                                                                                                                                                                                            * limit (number)

                                                                                                                                                                                                                                                                                                                                                            * search (string)

                                                                                                                                                                                                                                                                                                                                                               * Call listDocuments({ limit, search }).

                                                                                                                                                                                                                                                                                                                                                               * Return JSON array of documents, but omit content_text by default (to keep payload smaller).

                                                                                                                                                                                                                                                                                                                                                                  * You can either:

                                                                                                                                                                                                                                                                                                                                                                     * Exclude content_text in the SQL query, or

                                                                                                                                                                                                                                                                                                                                                                     * Include it and map it out before sending.

For simplicity, you can return the whole row including content_text, but note that the frontend will only display a trimmed preview. (Either approach is acceptable; document your choice in a comment.)
GET /api/documents/:id
                                                                                                                                                                                                                                                                                                                                                                        * Fetch document by ID with getDocumentById.

                                                                                                                                                                                                                                                                                                                                                                        * If not found, return 404 { error: 'Document not found' }.

                                                                                                                                                                                                                                                                                                                                                                        * Return the full document including content_text.

Later we may add endpoints to link documents to tasks; not needed in CT5.
1.6 Hook up routes
In server/src/app.ts:
import documentsRouter from './routes/documents';


app.use('/api/documents', documentsRouter);


Ensure any error-handling middleware is defined at the bottom of the file.
________________


2. Frontend – Document Browser & Upload UI
Work in client/.
2.1 Types & API helpers
Extend client/src/types/api.ts:
export interface Document {
  id: number;
  user_id: number;
  title: string;
  original_filename: string | null;
  source_path: string | null;
  content_text: string | null;
  uploaded_at: string;
  updated_at: string;
}


Create client/src/api/documents.ts:
import { apiRequest } from './client';
import type { Document } from '../types/api';


export interface ListDocumentsParams {
  limit?: number;
  search?: string;
}


export async function listDocuments(params: ListDocumentsParams = {}): Promise<Document[]> {
  const searchParams = new URLSearchParams();
  if (params.limit != null) searchParams.set('limit', String(params.limit));
  if (params.search) searchParams.set('search', params.search);


  const query = searchParams.toString();
  const path = query ? `/api/documents?${query}` : '/api/documents';
  return apiRequest<Document[]>(path);
}


export async function getDocument(id: number): Promise<Document> {
  return apiRequest<Document>(`/api/documents/${id}`);
}


export async function uploadDocument(file: File, title?: string): Promise<Document> {
  const formData = new FormData();
  formData.append('file', file);
  if (title) formData.append('title', title);


  const res = await fetch('/api/documents/upload', {
    method: 'POST',
    body: formData,
  });


  if (!res.ok) {
    let message = `Upload failed with status ${res.status}`;
    try {
      const data = await res.json();
      if (data && typeof data.error === 'string') {
        message = data.error;
      }
    } catch {
      // ignore
    }
    throw new Error(message);
  }


  return res.json() as Promise<Document>;
}


Note: This uploadDocument bypasses apiRequest because it uses FormData and must not set Content-Type manually.
2.2 Navigation
In client/src/App.tsx:
                                                                                                                                                                                                                                                                                                                                                                           * Add a new route /documents linked in the main nav:

                                                                                                                                                                                                                                                                                                                                                                              * Header links: “Dashboard”, “Tasks”, “Documents”.

                                                                                                                                                                                                                                                                                                                                                                                 * Import and use DocumentsPage (created below).

2.3 Documents page & components
Create client/src/pages/DocumentsPage.tsx:
State:
                                                                                                                                                                                                                                                                                                                                                                                    * documents: Document[]

                                                                                                                                                                                                                                                                                                                                                                                    * selectedDocument: Document | null

                                                                                                                                                                                                                                                                                                                                                                                    * loading: boolean

                                                                                                                                                                                                                                                                                                                                                                                    * error: string | null

                                                                                                                                                                                                                                                                                                                                                                                    * search: string

                                                                                                                                                                                                                                                                                                                                                                                    * uploading: boolean

Effects:
                                                                                                                                                                                                                                                                                                                                                                                       1. On mount (and when search changes, with a short debounce if you like, but not required), call listDocuments({ search }) and populate documents.

Handlers:
                                                                                                                                                                                                                                                                                                                                                                                          * handleSelectDocument(doc: Document) → set selectedDocument.

                                                                                                                                                                                                                                                                                                                                                                                          * handleUpload(file: File, title?: string):

                                                                                                                                                                                                                                                                                                                                                                                             * Set uploading = true.

                                                                                                                                                                                                                                                                                                                                                                                             * Call uploadDocument(file, title).

                                                                                                                                                                                                                                                                                                                                                                                             * On success:

                                                                                                                                                                                                                                                                                                                                                                                                * Push the new document into documents (or re-fetch with listDocuments).

                                                                                                                                                                                                                                                                                                                                                                                                * Set selectedDocument to the new document.

                                                                                                                                                                                                                                                                                                                                                                                                   * Handle errors by setting error.

Layout:
                                                                                                                                                                                                                                                                                                                                                                                                      * Two-column layout (similar to Tasks):

                                                                                                                                                                                                                                                                                                                                                                                                         * Left: document list + search + upload form.

                                                                                                                                                                                                                                                                                                                                                                                                         * Right: document detail/preview.

Create components:
client/src/components/DocumentUploadForm.tsx
Props:
interface DocumentUploadFormProps {
  onUpload: (file: File, title?: string) => void;
  uploading: boolean;
}


Behaviour:
                                                                                                                                                                                                                                                                                                                                                                                                            * Render:

                                                                                                                                                                                                                                                                                                                                                                                                               * A file input (input type="file").

                                                                                                                                                                                                                                                                                                                                                                                                               * Optional title input.

                                                                                                                                                                                                                                                                                                                                                                                                               * Upload button.

                                                                                                                                                                                                                                                                                                                                                                                                                  * When the user selects a file and clicks Upload:

                                                                                                                                                                                                                                                                                                                                                                                                                     * Call onUpload(file, title).

                                                                                                                                                                                                                                                                                                                                                                                                                        * Disable the button and show “Uploading…” if uploading is true.

client/src/components/DocumentList.tsx
Props:
interface DocumentListProps {
  documents: Document[];
  selectedDocumentId: number | null;
  onSelect: (doc: Document) => void;
}


Behaviour:
                                                                                                                                                                                                                                                                                                                                                                                                                           * Render a scrollable list of documents:

                                                                                                                                                                                                                                                                                                                                                                                                                              * Show title (or original_filename if title is missing).

                                                                                                                                                                                                                                                                                                                                                                                                                              * Show uploaded_at in a small, human-friendly date format.

                                                                                                                                                                                                                                                                                                                                                                                                                                 * Highlight the selected document.

                                                                                                                                                                                                                                                                                                                                                                                                                                 * On click, call onSelect(doc).

client/src/components/DocumentDetail.tsx
Props:
interface DocumentDetailProps {
  document: Document | null;
}


Behaviour:
                                                                                                                                                                                                                                                                                                                                                                                                                                    * If document is null, show a placeholder: “Select a document to view details.”

                                                                                                                                                                                                                                                                                                                                                                                                                                    * If not null:

                                                                                                                                                                                                                                                                                                                                                                                                                                       * Show:

                                                                                                                                                                                                                                                                                                                                                                                                                                          * Title

                                                                                                                                                                                                                                                                                                                                                                                                                                          * Original filename

                                                                                                                                                                                                                                                                                                                                                                                                                                          * Uploaded date

                                                                                                                                                                                                                                                                                                                                                                                                                                             * Show a text preview:

                                                                                                                                                                                                                                                                                                                                                                                                                                                * Use document.content_text || ''.

                                                                                                                                                                                                                                                                                                                                                                                                                                                * Truncate to, say, the first 1000–2000 characters.

                                                                                                                                                                                                                                                                                                                                                                                                                                                * Display in a <pre> or <div> with white-space: pre-wrap.

                                                                                                                                                                                                                                                                                                                                                                                                                                                   * (Optional) Later we’ll add “Create tasks from this doc” actions; for now, just display.

2.4 DocumentsPage layout
Example (you write actual TSX):
export function DocumentsPage() {
  // state, effects, handlers


  return (
    <div className="documents-page">
      <h1>Documents</h1>
      {error && <div className="error-banner">{error}</div>}
      <div className="documents-layout">
        <aside className="documents-sidebar">
          <div className="documents-search">
            <input
              type="text"
              placeholder="Search documents..."
              value={search}
              onChange={(e) => setSearch(e.target.value)}
            />
          </div>
          <DocumentUploadForm onUpload={handleUpload} uploading={uploading} />
          <DocumentList
            documents={documents}
            selectedDocumentId={selectedDocument ? selectedDocument.id : null}
            onSelect={handleSelectDocument}
          />
        </aside>
        <section className="documents-main">
          <DocumentDetail document={selectedDocument} />
        </section>
      </div>
    </div>
  );
}


________________


3. Basic styling
In client/src/index.css (or appropriate global stylesheet):
                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Add styles for:

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * .documents-page – overall container.

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * .documents-layout – two-column layout, using flexbox or CSS grid.

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * .documents-sidebar – narrow column (e.g. 280px), scrollable.

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * .documents-main – main content.

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * .error-banner – simple red text or box.

                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Inputs and buttons – basic padding/margins.

Reuse the same visual feel as the Tasks page so the app feels consistent.
________________


4. README update
In root README.md, extend the “API Overview” and “UI” sections:
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Add:

                                                                                                                                                                                                                                                                                                                                                                                                                                                               * POST /api/documents/upload – upload a file with multipart/form-data.

                                                                                                                                                                                                                                                                                                                                                                                                                                                               * GET /api/documents – list documents, with limit and search.

                                                                                                                                                                                                                                                                                                                                                                                                                                                               * GET /api/documents/:id – get a specific document, including content_text.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                  * Add a note that visiting /documents in the app:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Allows uploading and browsing documents.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Shows a text preview of extracted content.

________________


5. Acceptance criteria
CT5 is complete when:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        1. npm run dev from the repo root still starts backend and frontend successfully.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                        2. POST /api/documents/upload with a PDF/DOCX/TXT file:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Saves the file to server/uploads.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Creates a row in documents with populated title, original_filename, source_path, uploaded_at, updated_at, and a non-empty content_text for supported formats.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                              3. GET /api/documents returns a list of uploaded documents.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                              4. GET /api/documents/:id returns the full document including content_text.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                              5. Visiting http://localhost:3000/documents:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * Shows an upload form and a list of documents on the left.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 * Shows document details and a text preview on the right when a document is selected.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    6. Uploading a new document via the UI:

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       * Adds it to the list.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       * Selecting it shows metadata and a preview.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          7. There are no TypeScript errors in client or server, and the features behave reasonably on desktop and phone-width viewports.

Please output all new/changed files in full (TS, TSX, CSS, route files, etc.), with correct imports and exports, so I can paste them into the project and immediately get a working document upload + browser feature.
________________